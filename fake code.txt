// function is triggered after every save() function
function calculateActions() {
// calculate startpoints from relative time
// make array in the correct order of timestamps:
triggerSetup = [
	{pin: 1, startpoint: 0, endpoint: 100},	 // 1
	{pin: 2, startpoint: 0, endpoint: 100},	 // 2
	{pin: 3, startpoint: 400, endpoint: 500}, // 3
	{pin: 4, startpoint: 350, endpoint: 450}, // 4	
	{pin: 5, startpoint: 200, endpoint: 300}, // 5	
	{pin: 6, startpoint: 0, endpoint: 100},	 // 6
]
// should lead to
// every timestamp in ascending order with pin# and HIGH/LOW
triggerSetup.sortby(startpoint)
actions = [
	{
	 timestamp: first mutual startpoint,
	 pins: [{pin: 1, value: HIGH}, {pin: 3, value: HIGH}, {pin: 4, value: HIGH}]
	},
	{
	 timestamp: second mutual startpoint,
	 pins: [{pin: 2, value: HIGH}, {pin: 5, value: HIGH}]
	},
	...
]

// add all stop times to the same array
triggerSetup.sortby(endpoint)
actions += [
	{
	 timestamp: exists ? add : create new key,
	 pins: [{pin: 1, value: HIGH}, {pin: 3, value: HIGH}, {pin: 4, value: HIGH}, {pin: 6, value: LOW}]
	},
	{
	 timestamp: exists ? add : create new key,
	 pins: [2: HIGH, 5: HIGH, 1: LOW, 3: LOW, 4: LOW]
	 pins: [{pin: 2, value: HIGH}, {pin: 5, value: HIGH}, {pin: 1, value: LOW}, {pin: 3, value: LOW}, {pin: 4, value: LOW}]
	},
	...
]

triggerSetup.sortby(timestamp)  // resort
}


function triggered() {
while triggerBtnTrue:
	delay initialDelay
	for (action, i) in actions:
		delay action[i].timestamp
		for (pin, x) in action[i].pins:
			digitalWrite(action[i].pins[x].pin, action[i].pins[x].value)
		triggerBtnTrue = digitalRead(triggerBtnPin)
		// maybe no digitalRead here because it slows down.. but perhaps consitently?
	triggerBtnTrue = False 
}